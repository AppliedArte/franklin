"""Proactive Engine - Monitors conditions and triggers autonomous actions."""

from __future__ import annotations

import asyncio
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from typing import Any, Callable, Optional
from uuid import UUID, uuid4

from src.config import get_settings
from src.proactive.triggers import (
    Trigger, TriggerType, TriggerAction, TriggerRule, get_default_triggers
)

settings = get_settings()


@dataclass
class ProactiveNotification:
    """A notification generated by proactive monitoring."""
    id: UUID = field(default_factory=uuid4)
    user_id: UUID = None
    trigger_id: UUID = None
    trigger_name: str = ""
    message: str = ""
    action_type: TriggerAction = TriggerAction.NOTIFY
    suggested_action: Optional[dict] = None  # If action_type is SUGGEST
    priority: int = 5
    created_at: datetime = field(default_factory=datetime.utcnow)
    delivered: bool = False
    delivered_at: Optional[datetime] = None
    channel: str = ""
    dismissed: bool = False

    def to_dict(self) -> dict:
        return {
            "id": str(self.id),
            "message": self.message,
            "action_type": self.action_type.value,
            "priority": self.priority,
            "created_at": self.created_at.isoformat(),
            "delivered": self.delivered,
        }


@dataclass
class UserContext:
    """User context for evaluating trigger conditions."""
    user_id: UUID
    calendar_events: list[dict] = field(default_factory=list)
    accounts: list[dict] = field(default_factory=list)
    recent_transactions: list[dict] = field(default_factory=list)
    saved_searches: list[dict] = field(default_factory=list)
    watchlist: list[dict] = field(default_factory=list)
    settings: dict = field(default_factory=dict)


class ProactiveEngine:
    """Engine for monitoring and triggering proactive actions."""

    def __init__(self):
        self.rules: dict[UUID, TriggerRule] = {}
        self.user_triggers: dict[UUID, list[UUID]] = {}  # user_id -> rule_ids
        self.notifications: dict[UUID, list[ProactiveNotification]] = {}
        self._trigger_history: dict[UUID, list[datetime]] = {}  # rule_id -> trigger times
        self._running = False
        self._check_interval = 60  # seconds

        # Load default triggers
        for rule in get_default_triggers():
            self.register_rule(rule)

    def register_rule(self, rule: TriggerRule) -> None:
        """Register a trigger rule."""
        self.rules[rule.id] = rule

    def enable_for_user(self, user_id: UUID, rule_id: UUID) -> bool:
        """Enable a trigger rule for a user."""
        if rule_id not in self.rules:
            return False

        if user_id not in self.user_triggers:
            self.user_triggers[user_id] = []

        if rule_id not in self.user_triggers[user_id]:
            self.user_triggers[user_id].append(rule_id)

        return True

    def disable_for_user(self, user_id: UUID, rule_id: UUID) -> bool:
        """Disable a trigger rule for a user."""
        if user_id in self.user_triggers and rule_id in self.user_triggers[user_id]:
            self.user_triggers[user_id].remove(rule_id)
            return True
        return False

    def enable_all_defaults(self, user_id: UUID) -> None:
        """Enable all default triggers for a user."""
        for rule_id in self.rules:
            self.enable_for_user(user_id, rule_id)

    async def check_triggers(
        self,
        user_id: UUID,
        context: UserContext,
    ) -> list[ProactiveNotification]:
        """Check all enabled triggers for a user and return notifications."""
        if user_id not in self.user_triggers:
            return []

        notifications = []
        now = datetime.utcnow()

        for rule_id in self.user_triggers[user_id]:
            rule = self.rules.get(rule_id)
            if not rule or not rule.is_active:
                continue

            # Check cooldown
            if not self._check_cooldown(rule):
                continue

            # Check max per day
            if not self._check_daily_limit(rule):
                continue

            # Evaluate the trigger
            should_trigger, data = await self._evaluate_trigger(rule, context)

            if should_trigger:
                notification = self._create_notification(
                    user_id=user_id,
                    rule=rule,
                    data=data,
                )
                notifications.append(notification)

                # Record trigger
                if rule.id not in self._trigger_history:
                    self._trigger_history[rule.id] = []
                self._trigger_history[rule.id].append(now)

        # Store notifications
        if user_id not in self.notifications:
            self.notifications[user_id] = []
        self.notifications[user_id].extend(notifications)

        return notifications

    async def _evaluate_trigger(
        self,
        rule: TriggerRule,
        context: UserContext,
    ) -> tuple[bool, dict]:
        """Evaluate if a trigger should fire."""
        if rule.trigger_type == TriggerType.SCHEDULED:
            # Cron-based - would need cron parser
            # For now, return False (handled by scheduler)
            return False, {}

        elif rule.trigger_type == TriggerType.CONDITION:
            return self._evaluate_condition(rule, context)

        elif rule.trigger_type == TriggerType.EVENT:
            # Event-based triggers handled separately
            return False, {}

        return False, {}

    def _evaluate_condition(
        self,
        rule: TriggerRule,
        context: UserContext,
    ) -> tuple[bool, dict]:
        """Evaluate a condition-based trigger."""
        expression = rule.condition_expression
        data = {}

        # Simple condition evaluation
        # In production, use a proper expression evaluator

        if "trip" in expression.lower() and "calendar" in expression.lower():
            # Trip booking reminder
            for event in context.calendar_events:
                title = event.get("title", "").lower()
                if "trip" in title or "travel" in title or "flight" in title:
                    start = event.get("start")
                    if isinstance(start, str):
                        start = datetime.fromisoformat(start.replace("Z", "+00:00"))
                    if start:
                        days_until = (start - datetime.utcnow()).days
                        if 0 < days_until <= 14:
                            data = {
                                "destination": event.get("location", "your destination"),
                                "days": days_until,
                                "event": event,
                            }
                            return True, data

        elif "balance" in expression.lower() and "threshold" in expression.lower():
            # Low balance alert
            threshold = context.settings.get("low_balance_threshold", 500)
            for account in context.accounts:
                if account.get("type") == "checking":
                    balance = account.get("balance", 0)
                    if balance < threshold:
                        data = {
                            "account_name": account.get("name"),
                            "balance": balance,
                            "threshold": threshold,
                        }
                        return True, data

        elif "spending" in expression.lower() and "average" in expression.lower():
            # Unusual spending
            today_total = sum(
                abs(t.get("amount", 0))
                for t in context.recent_transactions
                if t.get("date") == datetime.utcnow().date().isoformat()
            )
            # Mock average
            daily_average = context.settings.get("daily_spending_average", 100)
            if today_total > daily_average * 2:
                data = {
                    "amount": today_total,
                    "average": daily_average,
                }
                return True, data

        elif "price" in expression.lower() and "saved_search" in expression.lower():
            # Price drop alert
            for search in context.saved_searches:
                if search.get("type") == "flight":
                    current = search.get("current_price", 0)
                    original = search.get("original_price", 0)
                    if original > 0 and current < original * 0.85:
                        data = {
                            "route": search.get("route"),
                            "price": current,
                            "original": original,
                            "drop_pct": round((1 - current / original) * 100),
                        }
                        return True, data

        elif "stock" in expression.lower() and "change" in expression.lower():
            # Stock alert
            for stock in context.watchlist:
                change_pct = stock.get("change_pct", 0)
                if abs(change_pct) > 5:
                    data = {
                        "symbol": stock.get("symbol"),
                        "price": stock.get("price"),
                        "change": change_pct,
                        "direction": "up" if change_pct > 0 else "down",
                        "reason": "",
                    }
                    return True, data

        return False, {}

    def _check_cooldown(self, rule: TriggerRule) -> bool:
        """Check if cooldown period has passed."""
        if rule.id not in self._trigger_history:
            return True

        history = self._trigger_history[rule.id]
        if not history:
            return True

        last_trigger = max(history)
        cooldown_end = last_trigger + timedelta(hours=rule.cooldown_hours)

        return datetime.utcnow() > cooldown_end

    def _check_daily_limit(self, rule: TriggerRule) -> bool:
        """Check if daily trigger limit has been reached."""
        if rule.id not in self._trigger_history:
            return True

        history = self._trigger_history[rule.id]
        today = datetime.utcnow().date()
        today_count = sum(1 for t in history if t.date() == today)

        return today_count < rule.max_triggers_per_day

    def _create_notification(
        self,
        user_id: UUID,
        rule: TriggerRule,
        data: dict,
    ) -> ProactiveNotification:
        """Create a notification from a triggered rule."""
        # Format the message
        message_template = rule.action_config.get("message", rule.description)
        try:
            message = message_template.format(**data)
        except KeyError:
            message = message_template

        notification = ProactiveNotification(
            user_id=user_id,
            trigger_id=rule.id,
            trigger_name=rule.name,
            message=message,
            action_type=rule.action,
            priority=rule.priority,
        )

        # Add suggested action if applicable
        if rule.action == TriggerAction.SUGGEST:
            notification.suggested_action = {
                "tool": rule.action_config.get("tool"),
                "action": rule.action_config.get("action"),
                "parameters": data,
            }

        return notification

    async def get_pending_notifications(
        self,
        user_id: UUID,
        limit: int = 10,
    ) -> list[ProactiveNotification]:
        """Get pending notifications for a user."""
        if user_id not in self.notifications:
            return []

        pending = [
            n for n in self.notifications[user_id]
            if not n.delivered and not n.dismissed
        ]

        # Sort by priority (higher first) then by creation time
        pending.sort(key=lambda n: (-n.priority, n.created_at))

        return pending[:limit]

    async def mark_delivered(
        self,
        notification_id: UUID,
        channel: str = "",
    ) -> bool:
        """Mark a notification as delivered."""
        for user_notifications in self.notifications.values():
            for n in user_notifications:
                if n.id == notification_id:
                    n.delivered = True
                    n.delivered_at = datetime.utcnow()
                    n.channel = channel
                    return True
        return False

    async def dismiss_notification(self, notification_id: UUID) -> bool:
        """Dismiss a notification."""
        for user_notifications in self.notifications.values():
            for n in user_notifications:
                if n.id == notification_id:
                    n.dismissed = True
                    return True
        return False

    def get_user_rules(self, user_id: UUID) -> list[TriggerRule]:
        """Get all rules enabled for a user."""
        if user_id not in self.user_triggers:
            return []

        return [
            self.rules[rule_id]
            for rule_id in self.user_triggers[user_id]
            if rule_id in self.rules
        ]

    async def run_scheduled_check(self) -> dict[UUID, list[ProactiveNotification]]:
        """Run a check for all users (called by scheduler)."""
        all_notifications = {}

        for user_id in self.user_triggers:
            # In production, load context from database
            context = UserContext(user_id=user_id)
            notifications = await self.check_triggers(user_id, context)
            if notifications:
                all_notifications[user_id] = notifications

        return all_notifications
